// Generated by @dartnative/codegen:
// https://www.npmjs.com/package/@dartnative/codegen

import 'dart:ffi';

import 'package:dart_native/dart_native.dart';
import 'package:dart_native_gen/dart_native_gen.dart';
import 'package:sounds/src/ios/frameworks/avfoundation/avaudioformat.dart';
import 'package:sounds/src/ios/frameworks/avfoundation/nsurl.dart';

import 'avaudiosessionroute.dart';
import 'hacks.dart';
// You can uncomment this line when this package is ready.
// import 'package:avfaudio/avaudioformat.dart';
// You can uncomment this line when this package is ready.
// import 'package:avfaudio/avaudiosettings.dart';
// You can uncomment this line when this package is ready.
// import 'package:avfaudio/avaudiosession.dart';

@NativeAvailable(macos: '10.7', ios: '3.0', watchos: '4.0')
@NativeUnavailable(tvos)
@native
class AVAudioRecorder extends NSObject {
  AVAudioRecorder([Class isa]) : super(isa ?? Class('AVAudioRecorder'));
  AVAudioRecorder.fromPointer(Pointer<Void> ptr) : super.fromPointer(ptr);

  bool get recording {
    return perform(SEL('recording')) as bool;
  }

  set recording(bool recording) =>
      perform(SEL('setRecording:'), args: <dynamic>[recording]);

  NSURL get url {
    Pointer<Void> result =
        perform(SEL('url'), decodeRetVal: false) as Pointer<Void>;
    return NSURL.fromPointer(result);
  }

  set url(NSURL url) => perform(SEL('setUrl:'), args: <dynamic>[url]);

  id get settings {
    Pointer<Void> result =
        perform(SEL('settings'), decodeRetVal: false) as Pointer<Void>;
    return id(result);
  }

  set settings(id settings) =>
      perform(SEL('setSettings:'), args: <dynamic>[settings]);
  @NativeAvailable(macos: '10.12', ios: '10.0', watchos: '4.0')
  @NativeUnavailable(tvos)
  AVAudioFormat get format {
    Pointer<Void> result =
        perform(SEL('format'), decodeRetVal: false) as Pointer<Void>;
    return AVAudioFormat.fromPointer(result);
  }

  @NativeAvailable(macos: '10.12', ios: '10.0', watchos: '4.0')
  @NativeUnavailable(tvos)
  set format(AVAudioFormat format) =>
      perform(SEL('setFormat:'), args: <dynamic>[format]);

  AVAudioRecorderDelegate get delegate {
    Pointer<Void> result =
        perform(SEL('delegate'), decodeRetVal: false) as Pointer<Void>;
    return AVAudioRecorder.fromPointer(result).delegate;
  }

  set delegate(AVAudioRecorderDelegate delegate) =>
      perform(SEL('setDelegate:'), args: <dynamic>[delegate]);

  NSTimeInterval get currentTime {
    var result =
        perform(SEL('currentTime'), decodeRetVal: false) as Pointer<Void>;
    return NSTimeInterval.fromPointer(result);
  }

  set currentTime(NSTimeInterval currentTime) =>
      perform(SEL('setCurrentTime:'), args: <dynamic>[currentTime]);
  NSTimeInterval get deviceCurrentTime {
    var result =
        perform(SEL('deviceCurrentTime'), decodeRetVal: false) as Pointer<Void>;
    return NSTimeInterval.fromPointer(result);
  }

  @NativeAvailable(macos: '10.9', ios: '6.0', watchos: '4.0')
  @NativeUnavailable(tvos)
  set deviceCurrentTime(NSTimeInterval deviceCurrentTime) =>
      perform(SEL('setDeviceCurrentTime:'), args: <dynamic>[deviceCurrentTime]);

  bool get meteringEnabled {
    return perform(SEL('meteringEnabled')) as bool;
  }

  set meteringEnabled(bool meteringEnabled) =>
      perform(SEL('setMeteringEnabled:'), args: <dynamic>[meteringEnabled]);
  AVAudioSessionChannelDescription get channelAssignments {
    Pointer<Void> result =
        perform(SEL('channelAssignments'), decodeRetVal: false)
            as Pointer<Void>;
    return AVAudioSessionChannelDescription.fromPointer(result);
  }

  @NativeAvailable(ios: '7.0', watchos: '4.0')
  @NativeUnavailable(macos)
  @NativeUnavailable(tvos)
  set channelAssignments(AVAudioSessionChannelDescription channelAssignments) =>
      perform(SEL('setChannelAssignments:'),
          args: <dynamic>[channelAssignments]);
  AVAudioRecorder.initWithURLSettingsError(
      NSURL url, NSObject settings, NSObjectRef<NSError> outError)
      : super.fromPointer(_initWithURLSettingsError(url, settings, outError));

  static Pointer<Void> _initWithURLSettingsError(
      NSURL url, NSObject settings, NSObjectRef<NSError> outError) {
    Pointer<Void> target = alloc(Class('AVAudioRecorder'));
    SEL sel = SEL('initWithURL:settings:error:');
    return msgSend(target, sel,
        args: <dynamic>[url, settings, outError],
        decodeRetVal: false) as Pointer<Void>;
  }

  AVAudioRecorder.initWithURLFormatError(
      NSURL url, AVAudioFormat format, NSObjectRef<NSError> outError)
      : super.fromPointer(_initWithURLFormatError(url, format, outError));

  static Pointer<Void> _initWithURLFormatError(
      NSURL url, AVAudioFormat format, NSObjectRef<NSError> outError) {
    Pointer<Void> target = alloc(Class('AVAudioRecorder'));
    SEL sel = SEL('initWithURL:format:error:');
    return msgSend(target, sel,
        args: <dynamic>[url, format, outError],
        decodeRetVal: false) as Pointer<Void>;
  }

  bool prepareToRecord() {
    return perform(SEL('prepareToRecord')) as bool;
  }

  bool record() {
    return perform(SEL('record')) as bool;
  }

  @NativeAvailable(macos: '10.9', ios: '6.0', watchos: '4.0')
  @NativeUnavailable(tvos)
  bool recordAtTime(NSTimeInterval time) {
    return perform(SEL('recordAtTime:'), args: <dynamic>[time]) as bool;
  }

  bool recordForDuration(NSTimeInterval duration) {
    return perform(SEL('recordForDuration:'), args: <dynamic>[duration])
        as bool;
  }

  @NativeAvailable(macos: '10.9', ios: '6.0', watchos: '4.0')
  @NativeUnavailable(tvos)
  bool recordAtTimeForDuration(NSTimeInterval time, NSTimeInterval duration) {
    return perform(SEL('recordAtTime:forDuration:'),
        args: <dynamic>[time, duration]) as bool;
  }

  void pause() {
    perform(SEL('pause'));
  }

  void stop() {
    perform(SEL('stop'));
  }

  bool deleteRecording() {
    return perform(SEL('deleteRecording')) as bool;
  }

  void updateMeters() {
    perform(SEL('updateMeters'));
  }

  double peakPowerForChannel(NSUInteger channelNumber) {
    return perform(SEL('peakPowerForChannel:'), args: <dynamic>[channelNumber])
        as double;
  }

  double averagePowerForChannel(NSUInteger channelNumber) {
    return perform(SEL('averagePowerForChannel:'),
        args: <dynamic>[channelNumber]) as double;
  }
}

@NativeAvailable(macos: '10.7', ios: '3.0', watchos: '4.0')
@NativeUnavailable(tvos)
abstract class AVAudioRecorderDelegate {
  void registerAVAudioRecorderDelegate() {
    registerProtocolCallback(
        this,
        audioRecorderDidFinishRecordingSuccessfully,
        'audioRecorderDidFinishRecording:successfully:',
        AVAudioRecorderDelegate);
    registerProtocolCallback(this, audioRecorderEncodeErrorDidOccurError,
        'audioRecorderEncodeErrorDidOccur:error:', AVAudioRecorderDelegate);
    registerProtocolCallback(this, audioRecorderBeginInterruption,
        'audioRecorderBeginInterruption:', AVAudioRecorderDelegate);
    registerProtocolCallback(this, audioRecorderEndInterruptionWithOptions,
        'audioRecorderEndInterruption:withOptions:', AVAudioRecorderDelegate);
    registerProtocolCallback(this, audioRecorderEndInterruptionWithFlags,
        'audioRecorderEndInterruption:withFlags:', AVAudioRecorderDelegate);
    registerProtocolCallback(this, audioRecorderEndInterruption,
        'audioRecorderEndInterruption:', AVAudioRecorderDelegate);
  }

  void audioRecorderDidFinishRecordingSuccessfully(
      AVAudioRecorder recorder, bool flag);
  void audioRecorderEncodeErrorDidOccurError(AVAudioRecorder recorder,
      {NSError error});
  void audioRecorderBeginInterruption(AVAudioRecorder recorder);
  void audioRecorderEndInterruptionWithOptions(
      AVAudioRecorder recorder, NSUInteger flags);
  void audioRecorderEndInterruptionWithFlags(
      AVAudioRecorder recorder, NSUInteger flags);
  void audioRecorderEndInterruption(AVAudioRecorder recorder);
}

// Generated by @dartnative/codegen:
// https://www.npmjs.com/package/@dartnative/codegen

import 'dart:ffi';

import 'package:dart_native/dart_native.dart';
import 'package:dart_native_gen/dart_native_gen.dart';
import 'package:sounds/src/ios/frameworks/avfoundation/avaudioformat.dart';

import 'avaudioframeposition.dart';
import 'avaudionode.dart';
// You can uncomment this line when this package is ready.
// import 'package:avfaudio/avaudiobuffer.dart';
// You can uncomment this line when this package is ready.
// import 'package:avfaudio/avaudioconnectionpoint.dart';
// You can uncomment this line when this package is ready.
// import 'package:avfaudio/avaudioionode.dart';
// You can uncomment this line when this package is ready.
// import 'package:avfaudio/avaudiotime.dart';
// You can uncomment this line when this package is ready.
// import 'package:audiotoolbox/musicplayer.dart';
// You can uncomment this line when this package is ready.
// import 'package:audiotoolbox/auaudiounit.dart';

@NativeAvailable(macos: '10.13', ios: '11.0', watchos: '4.0', tvos: '11.0')
class AVAudioEngineManualRenderingError extends NSEnum {
  const AVAudioEngineManualRenderingError(dynamic raw) : super(raw as int);
  AVAudioEngineManualRenderingError.fromPointer(Pointer<Void> ptr)
      : super(ptr.address);
}

//TODO -X const vals are guesses need to check these at some point
const AVAudioEngineManualRenderingError
    AVAudioEngineManualRenderingErrorInvalidMode =
    AVAudioEngineManualRenderingError(-0);

const AVAudioEngineManualRenderingError
    AVAudioEngineManualRenderingErrorInitialized =
    AVAudioEngineManualRenderingError(-1);

const AVAudioEngineManualRenderingError
    AVAudioEngineManualRenderingErrorNotRunning =
    AVAudioEngineManualRenderingError(-2);

@NativeAvailable(macos: '10.13', ios: '11.0', watchos: '4.0', tvos: '11.0')
class AVAudioEngineManualRenderingStatus extends NSEnum {
  const AVAudioEngineManualRenderingStatus(dynamic raw) : super(raw as int);
  AVAudioEngineManualRenderingStatus.fromPointer(Pointer<Void> ptr)
      : super(ptr.address);
}

const AVAudioEngineManualRenderingStatus
    AVAudioEngineManualRenderingStatusError =
    AVAudioEngineManualRenderingStatus(-3);

const AVAudioEngineManualRenderingStatus
    AVAudioEngineManualRenderingStatusSuccess =
    AVAudioEngineManualRenderingStatus(0);

const AVAudioEngineManualRenderingStatus
    AVAudioEngineManualRenderingStatusInsufficientDataFromInputNode =
    AVAudioEngineManualRenderingStatus(1);

const AVAudioEngineManualRenderingStatus
    AVAudioEngineManualRenderingStatusCannotDoInCurrentContext =
    AVAudioEngineManualRenderingStatus(2);

@NativeAvailable(macos: '10.13', ios: '11.0', watchos: '4.0', tvos: '11.0')
class AVAudioEngineManualRenderingMode extends NSEnum {
  const AVAudioEngineManualRenderingMode(dynamic raw) : super(raw as int);
  AVAudioEngineManualRenderingMode.fromPointer(Pointer<Void> ptr)
      : super(ptr.address);
}

const AVAudioEngineManualRenderingMode AVAudioEngineManualRenderingModeOffline =
    AVAudioEngineManualRenderingMode(0);

const AVAudioEngineManualRenderingMode
    AVAudioEngineManualRenderingModeRealtime =
    AVAudioEngineManualRenderingMode(1);

// last param type was OSStatus which is just an int anyway
// typedef AVAudioEngineManualRenderingStatus AVAudioEngineManualRenderingBlock(
//     AVAudioFrameCount numberOfFrames, AudioBufferList outBuffer, int outError);

@NativeAvailable(macos: '10.10', ios: '8.0', watchos: '2.0', tvos: '9.0')
@native
class AVAudioEngine extends NSObject {
  AVAudioEngine([Class isa]) : super(isa ?? Class('AVAudioEngine'));
  AVAudioEngine.fromPointer(Pointer<Void> ptr) : super.fromPointer(ptr);

  // MusicSequence get musicSequence {
  //   Pointer<Void> result =
  //       perform(SEL('musicSequence'), decodeRetVal: false) as Pointer<Void>;
  //   return MusicSequence.fromPointer(result);
  // }

  // set musicSequence(MusicSequence musicSequence) =>
  //     perform(SEL('setMusicSequence:'), args: <dynamic>[musicSequence]);

  // AVAudioOutputNode get outputNode {
  //   Pointer<Void> result =
  //       perform(SEL('outputNode'), decodeRetVal: false) as Pointer<Void>;
  //   return AVAudioOutputNode.fromPointer(result);
  // }

  // set outputNode(AVAudioOutputNode outputNode) =>
  //     perform(SEL('setOutputNode:'), args: <dynamic>[outputNode]);

  // @NativeAvailable(macos: '10.10', ios: '8.0', watchos: '4.0', tvos: '11.0')
  // AVAudioInputNode get inputNode {
  //   Pointer<Void> result =
  //       perform(SEL('inputNode'), decodeRetVal: false) as Pointer<Void>;
  //   return AVAudioInputNode.fromPointer(result);
  // }

  // @NativeAvailable(macos: '10.10', ios: '8.0', watchos: '4.0', tvos: '11.0')
  // set inputNode(AVAudioInputNode inputNode) =>
  //     perform(SEL('setInputNode:'), args: <dynamic>[inputNode]);

  // AVAudioMixerNode get mainMixerNode {
  //   Pointer<Void> result =
  //       perform(SEL('mainMixerNode'), decodeRetVal: false) as Pointer<Void>;
  //   return AVAudioMixerNode.fromPointer(result);
  // }

  // set mainMixerNode(AVAudioMixerNode mainMixerNode) =>
  //     perform(SEL('setMainMixerNode:'), args: <dynamic>[mainMixerNode]);

  bool get running {
    return perform(SEL('running')) as bool;
  }

  set running(bool running) =>
      perform(SEL('setRunning:'), args: <dynamic>[running]);
  @NativeAvailable(macos: '10.13', ios: '11.0', tvos: '11.0')
  @NativeUnavailable(watchos)
  bool get autoShutdownEnabled {
    return perform(SEL('autoShutdownEnabled')) as bool;
  }

  @NativeAvailable(macos: '10.13', ios: '11.0', tvos: '11.0')
  @NativeUnavailable(watchos)
  set autoShutdownEnabled(bool autoShutdownEnabled) =>
      perform(SEL('setAutoShutdownEnabled:'),
          args: <dynamic>[autoShutdownEnabled]);
  @NativeAvailable(macos: '10.15', ios: '13.0', watchos: '6.0', tvos: '13.0')
  AVAudioNode get attachedNodes {
    Pointer<Void> result =
        perform(SEL('attachedNodes'), decodeRetVal: false) as Pointer<Void>;
    return AVAudioNode.fromPointer(result);
  }

  @NativeAvailable(macos: '10.15', ios: '13.0', watchos: '6.0', tvos: '13.0')
  set attachedNodes(AVAudioNode attachedNodes) =>
      perform(SEL('setAttachedNodes:'), args: <dynamic>[attachedNodes]);
  @NativeAvailable(macos: '10.13', ios: '11.0', watchos: '4.0', tvos: '11.0')

  ///this is already a const
  // AVAudioEngineManualRenderingBlock get manualRenderingBlock {
  //   Pointer<Void> result =
  //       perform(SEL('manualRenderingBlock'), decodeRetVal: false)
  //           as Pointer<Void>;
  //   return AVAudioEngineManualRenderingBlock;
  // }

  // @NativeAvailable(macos: '10.13', ios: '11.0', watchos: '4.0', tvos: '11.0')
  // set manualRenderingBlock(
  //         AVAudioEngineManualRenderingBlock manualRenderingBlock) =>
  //     perform(SEL('setManualRenderingBlock:'),
  //         args: <dynamic>[manualRenderingBlock]);
  // @NativeAvailable(macos: '10.13', ios: '11.0', watchos: '4.0', tvos: '11.0')
  // bool get isInManualRenderingMode {
  //   return perform(SEL('isInManualRenderingMode')) as bool;
  // }

  @NativeAvailable(macos: '10.13', ios: '11.0', watchos: '4.0', tvos: '11.0')
  set isInManualRenderingMode(bool isInManualRenderingMode) =>
      perform(SEL('setIsInManualRenderingMode:'),
          args: <dynamic>[isInManualRenderingMode]);
  @NativeAvailable(macos: '10.13', ios: '11.0', watchos: '4.0', tvos: '11.0')
  AVAudioEngineManualRenderingMode get manualRenderingMode {
    Pointer<Void> result =
        perform(SEL('manualRenderingMode'), decodeRetVal: false)
            as Pointer<Void>;
    return AVAudioEngineManualRenderingMode.fromPointer(result);
  }

  @NativeAvailable(macos: '10.13', ios: '11.0', watchos: '4.0', tvos: '11.0')
  set manualRenderingMode(
          AVAudioEngineManualRenderingMode manualRenderingMode) =>
      perform(SEL('setManualRenderingMode:'),
          args: <dynamic>[manualRenderingMode]);
  @NativeAvailable(macos: '10.13', ios: '11.0', watchos: '4.0', tvos: '11.0')
  AVAudioFormat get manualRenderingFormat {
    Pointer<Void> result =
        perform(SEL('manualRenderingFormat'), decodeRetVal: false)
            as Pointer<Void>;
    return AVAudioFormat.fromPointer(result);
  }

  @NativeAvailable(macos: '10.13', ios: '11.0', watchos: '4.0', tvos: '11.0')
  set manualRenderingFormat(AVAudioFormat manualRenderingFormat) =>
      perform(SEL('setManualRenderingFormat:'),
          args: <dynamic>[manualRenderingFormat]);
  @NativeAvailable(macos: '10.13', ios: '11.0', watchos: '4.0', tvos: '11.0')
  // AVAudioFrameCount get manualRenderingMaximumFrameCount {
  //   Pointer<Void> result =
  //       perform(SEL('manualRenderingMaximumFrameCount'), decodeRetVal: false)
  //           as Pointer<Void>;
  //   return AVAudioFrameCount.fromPointer(result);
  // }

  // @NativeAvailable(macos: '10.13', ios: '11.0', watchos: '4.0', tvos: '11.0')
  // set manualRenderingMaximumFrameCount(
  //         AVAudioFrameCount manualRenderingMaximumFrameCount) =>
  //     perform(SEL('setManualRenderingMaximumFrameCount:'),
  //         args: <dynamic>[manualRenderingMaximumFrameCount]);
  @NativeAvailable(macos: '10.13', ios: '11.0', watchos: '4.0', tvos: '11.0')
  AVAudioFramePosition get manualRenderingSampleTime {
    Pointer<Void> result =
        perform(SEL('manualRenderingSampleTime'), decodeRetVal: false)
            as Pointer<Void>;
    return AVAudioFramePosition.fromPointer(result);
  }

  @NativeAvailable(macos: '10.13', ios: '11.0', watchos: '4.0', tvos: '11.0')
  set manualRenderingSampleTime(
          AVAudioFramePosition manualRenderingSampleTime) =>
      perform(SEL('setManualRenderingSampleTime:'),
          args: <dynamic>[manualRenderingSampleTime]);
  AVAudioEngine.empty() : super.fromPointer(_init());

  static Pointer<Void> _init() {
    Pointer<Void> target = alloc(Class('AVAudioEngine'));
    SEL sel = SEL('init');
    return msgSend(target, sel, args: <dynamic>[], decodeRetVal: false)
        as Pointer<Void>;
  }

  void attachNode(AVAudioNode node) {
    perform(SEL('attachNode:'), args: <dynamic>[node]);
  }

  void detachNode(AVAudioNode node) {
    perform(SEL('detachNode:'), args: <dynamic>[node]);
  }

  // void connectToFromBusToBusFormat(AVAudioNode node1, AVAudioNode node2,
  //     AVAudioNodeBus bus1, AVAudioNodeBus bus2,
  //     {AVAudioFormat format}) {
  //   perform(SEL('connect:to:fromBus:toBus:format:'),
  //       args: <dynamic>[node1, node2, bus1, bus2, format]);
  // }

  void connectToFormat(AVAudioNode node1, AVAudioNode node2,
      {AVAudioFormat format}) {
    perform(SEL('connect:to:format:'), args: <dynamic>[node1, node2, format]);
  }

  // @NativeAvailable(macos: '10.11', ios: '9.0', watchos: '2.0', tvos: '9.0')
  // void connectToConnectionPointsFromBusFormat(AVAudioNode sourceNode,
  //     AVAudioConnectionPoint destNodes, AVAudioNodeBus sourceBus,
  //     {AVAudioFormat format}) {
  //   perform(SEL('connect:toConnectionPoints:fromBus:format:'),
  //       args: <dynamic>[sourceNode, destNodes, sourceBus, format]);
  // }

  // void disconnectNodeInputBus(AVAudioNode node, AVAudioNodeBus bus) {
  //   perform(SEL('disconnectNodeInput:bus:'), args: <dynamic>[node, bus]);
  // }

  void disconnectNodeInput(AVAudioNode node) {
    perform(SEL('disconnectNodeInput:'), args: <dynamic>[node]);
  }

  // void disconnectNodeOutputBus(AVAudioNode node, AVAudioNodeBus bus) {
  //   perform(SEL('disconnectNodeOutput:bus:'), args: <dynamic>[node, bus]);
  // }

  void disconnectNodeOutput(AVAudioNode node) {
    perform(SEL('disconnectNodeOutput:'), args: <dynamic>[node]);
  }

  void prepare() {
    perform(SEL('prepare'));
  }

  bool startAndReturnError(NSObjectRef<NSError> outError) {
    return perform(SEL('startAndReturnError:'), args: <dynamic>[outError])
        as bool;
  }

  void pause() {
    perform(SEL('pause'));
  }

  void reset() {
    perform(SEL('reset'));
  }

  void stop() {
    perform(SEL('stop'));
  }

  // @NativeAvailable(macos: '10.11', ios: '9.0', watchos: '2.0', tvos: '9.0')
  // AVAudioConnectionPoint inputConnectionPointForNodeInputBus(
  //     AVAudioNode node, AVAudioNodeBus bus) {
  //   Pointer<Void> result = perform(SEL('inputConnectionPointForNode:inputBus:'),
  //       args: <dynamic>[node, bus], decodeRetVal: false) as Pointer<Void>;
  //   return AVAudioConnectionPoint.fromPointer(result);
  // }

  // @NativeAvailable(macos: '10.11', ios: '9.0', watchos: '2.0', tvos: '9.0')
  // AVAudioConnectionPoint outputConnectionPointsForNodeOutputBus(
  //     AVAudioNode node, AVAudioNodeBus bus) {
  //   Pointer<Void> result = perform(
  //       SEL('outputConnectionPointsForNode:outputBus:'),
  //       args: <dynamic>[node, bus],
  //       decodeRetVal: false) as Pointer<Void>;
  //   return AVAudioConnectionPoint.fromPointer(result);
  // }

  // @NativeAvailable(macos: '10.13', ios: '11.0', watchos: '4.0', tvos: '11.0')
  // bool enableManualRenderingModeFormatMaximumFrameCountError(
  //     AVAudioEngineManualRenderingMode mode,
  //     AVAudioFormat pcmFormat,
  //     AVAudioFrameCount maximumFrameCount,
  //     NSObjectRef<NSError> outError) {
  //   return perform(
  //       SEL('enableManualRenderingMode:format:maximumFrameCount:error:'),
  //       args: <dynamic>[mode, pcmFormat, maximumFrameCount, outError]) as bool;
  // }

  @NativeAvailable(macos: '10.13', ios: '11.0', watchos: '4.0', tvos: '11.0')
  void disableManualRenderingMode() {
    perform(SEL('disableManualRenderingMode'));
  }

  @NativeAvailable(macos: '10.13', ios: '11.0', watchos: '4.0', tvos: '11.0')
  // AVAudioEngineManualRenderingStatus renderOfflineToBufferError(
  //     AVAudioFrameCount numberOfFrames,
  //     AVAudioPCMBuffer buffer,
  //     NSObjectRef<NSError> outError) {
  //   Pointer<Void> result = perform(SEL('renderOffline:toBuffer:error:'),
  //       args: <dynamic>[numberOfFrames, buffer, outError],
  //       decodeRetVal: false) as Pointer<Void>;
  //   return AVAudioEngineManualRenderingStatus.fromPointer(result);
  // }

  // @NativeAvailable(macos: '10.14', ios: '12.0', watchos: '5.0', tvos: '12.0')
  // void connectMIDIToFormatBlock(
  //     AVAudioNode sourceNode, AVAudioNode destinationNode,
  //     {AVAudioFormat format, AUMIDIOutputEventBlock tapBlock}) {
  //   perform(SEL('connectMIDI:to:format:block:'),
  //       args: <dynamic>[sourceNode, destinationNode, format, tapBlock]);
  // }

  // @NativeAvailable(macos: '10.14', ios: '12.0', watchos: '5.0', tvos: '12.0')
  // void connectMIDIToNodesFormatBlock(
  //     AVAudioNode sourceNode, AVAudioNode destinationNodes,
  //     {AVAudioFormat format, AUMIDIOutputEventBlock tapBlock}) {
  //   perform(SEL('connectMIDI:toNodes:format:block:'),
  //       args: <dynamic>[sourceNode, destinationNodes, format, tapBlock]);
  // }

  @NativeAvailable(macos: '10.14', ios: '12.0', watchos: '5.0', tvos: '12.0')
  void disconnectMIDIFrom(AVAudioNode sourceNode, AVAudioNode destinationNode) {
    perform(SEL('disconnectMIDI:from:'),
        args: <dynamic>[sourceNode, destinationNode]);
  }

  @NativeAvailable(macos: '10.14', ios: '12.0', watchos: '5.0', tvos: '12.0')
  void disconnectMIDIFromNodes(
      AVAudioNode sourceNode, AVAudioNode destinationNodes) {
    perform(SEL('disconnectMIDI:fromNodes:'),
        args: <dynamic>[sourceNode, destinationNodes]);
  }

  @NativeAvailable(macos: '10.14', ios: '12.0', watchos: '5.0', tvos: '12.0')
  void disconnectMIDIInput(AVAudioNode node) {
    perform(SEL('disconnectMIDIInput:'), args: <dynamic>[node]);
  }

  @NativeAvailable(macos: '10.14', ios: '12.0', watchos: '5.0', tvos: '12.0')
  void disconnectMIDIOutput(AVAudioNode node) {
    perform(SEL('disconnectMIDIOutput:'), args: <dynamic>[node]);
  }
}

// Autogenerated from Pigeon (v0.1.10), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import
// @dart = 2.8
import 'dart:async';
import 'package:flutter/services.dart';
import 'dart:typed_data' show Uint8List, Int32List, Int64List, Float64List;

class Response {
  bool success;
  int errorCode;
  String error;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['success'] = success;
    pigeonMap['errorCode'] = errorCode;
    pigeonMap['error'] = error;
    return pigeonMap;
  }
  // ignore: unused_element
  static Response _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final Response result = Response();
    result.success = pigeonMap['success'];
    result.errorCode = pigeonMap['errorCode'];
    result.error = pigeonMap['error'];
    return result;
  }
}

class InitializePlayer {
  SoundPlayerProxy player;
  bool playInBackground;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['player'] = player == null ? null : player._toMap();
    pigeonMap['playInBackground'] = playInBackground;
    return pigeonMap;
  }
  // ignore: unused_element
  static InitializePlayer _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final InitializePlayer result = InitializePlayer();
    result.player = SoundPlayerProxy._fromMap(pigeonMap['player']);
    result.playInBackground = pigeonMap['playInBackground'];
    return result;
  }
}

class SoundPlayerProxy {
  String uuid;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['uuid'] = uuid;
    return pigeonMap;
  }
  // ignore: unused_element
  static SoundPlayerProxy _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final SoundPlayerProxy result = SoundPlayerProxy();
    result.uuid = pigeonMap['uuid'];
    return result;
  }
}

class InitializePlayerWithShade {
  SoundPlayerProxy player;
  bool playInBackground;
  bool canPause;
  bool canSkipBackward;
  bool canSkipForward;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['player'] = player == null ? null : player._toMap();
    pigeonMap['playInBackground'] = playInBackground;
    pigeonMap['canPause'] = canPause;
    pigeonMap['canSkipBackward'] = canSkipBackward;
    pigeonMap['canSkipForward'] = canSkipForward;
    return pigeonMap;
  }
  // ignore: unused_element
  static InitializePlayerWithShade _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final InitializePlayerWithShade result = InitializePlayerWithShade();
    result.player = SoundPlayerProxy._fromMap(pigeonMap['player']);
    result.playInBackground = pigeonMap['playInBackground'];
    result.canPause = pigeonMap['canPause'];
    result.canSkipBackward = pigeonMap['canSkipBackward'];
    result.canSkipForward = pigeonMap['canSkipForward'];
    return result;
  }
}

class StartPlayer {
  SoundPlayerProxy player;
  TrackProxy track;
  int startAt;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['player'] = player == null ? null : player._toMap();
    pigeonMap['track'] = track == null ? null : track._toMap();
    pigeonMap['startAt'] = startAt;
    return pigeonMap;
  }
  // ignore: unused_element
  static StartPlayer _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final StartPlayer result = StartPlayer();
    result.player = SoundPlayerProxy._fromMap(pigeonMap['player']);
    result.track = TrackProxy._fromMap(pigeonMap['track']);
    result.startAt = pigeonMap['startAt'];
    return result;
  }
}

class TrackProxy {
  String uuid;
  String path;
  MediaFormatProxy mediaFormat;
  String title;
  String artist;
  String album;
  String albumArtUrl;
  String albumArtAsset;
  String albumArtFile;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['uuid'] = uuid;
    pigeonMap['path'] = path;
    pigeonMap['mediaFormat'] = mediaFormat == null ? null : mediaFormat._toMap();
    pigeonMap['title'] = title;
    pigeonMap['artist'] = artist;
    pigeonMap['album'] = album;
    pigeonMap['albumArtUrl'] = albumArtUrl;
    pigeonMap['albumArtAsset'] = albumArtAsset;
    pigeonMap['albumArtFile'] = albumArtFile;
    return pigeonMap;
  }
  // ignore: unused_element
  static TrackProxy _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final TrackProxy result = TrackProxy();
    result.uuid = pigeonMap['uuid'];
    result.path = pigeonMap['path'];
    result.mediaFormat = MediaFormatProxy._fromMap(pigeonMap['mediaFormat']);
    result.title = pigeonMap['title'];
    result.artist = pigeonMap['artist'];
    result.album = pigeonMap['album'];
    result.albumArtUrl = pigeonMap['albumArtUrl'];
    result.albumArtAsset = pigeonMap['albumArtAsset'];
    result.albumArtFile = pigeonMap['albumArtFile'];
    return result;
  }
}

class MediaFormatProxy {
  String name;
  int sampleRate;
  int numChannels;
  int bitRate;
  String adtsAac;
  String capOpus;
  String mp3;
  String oggOpus;
  String oggVorbis;
  String pcm;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['name'] = name;
    pigeonMap['sampleRate'] = sampleRate;
    pigeonMap['numChannels'] = numChannels;
    pigeonMap['bitRate'] = bitRate;
    pigeonMap['adtsAac'] = adtsAac;
    pigeonMap['capOpus'] = capOpus;
    pigeonMap['mp3'] = mp3;
    pigeonMap['oggOpus'] = oggOpus;
    pigeonMap['oggVorbis'] = oggVorbis;
    pigeonMap['pcm'] = pcm;
    return pigeonMap;
  }
  // ignore: unused_element
  static MediaFormatProxy _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final MediaFormatProxy result = MediaFormatProxy();
    result.name = pigeonMap['name'];
    result.sampleRate = pigeonMap['sampleRate'];
    result.numChannels = pigeonMap['numChannels'];
    result.bitRate = pigeonMap['bitRate'];
    result.adtsAac = pigeonMap['adtsAac'];
    result.capOpus = pigeonMap['capOpus'];
    result.mp3 = pigeonMap['mp3'];
    result.oggOpus = pigeonMap['oggOpus'];
    result.oggVorbis = pigeonMap['oggVorbis'];
    result.pcm = pigeonMap['pcm'];
    return result;
  }
}

class SeekToPlayer {
  SoundPlayerProxy player;
  int milliseconds;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['player'] = player == null ? null : player._toMap();
    pigeonMap['milliseconds'] = milliseconds;
    return pigeonMap;
  }
  // ignore: unused_element
  static SeekToPlayer _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final SeekToPlayer result = SeekToPlayer();
    result.player = SoundPlayerProxy._fromMap(pigeonMap['player']);
    result.milliseconds = pigeonMap['milliseconds'];
    return result;
  }
}

class DurationResponse {
  bool success;
  int errorCode;
  String error;
  int duration;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['success'] = success;
    pigeonMap['errorCode'] = errorCode;
    pigeonMap['error'] = error;
    pigeonMap['duration'] = duration;
    return pigeonMap;
  }
  // ignore: unused_element
  static DurationResponse _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final DurationResponse result = DurationResponse();
    result.success = pigeonMap['success'];
    result.errorCode = pigeonMap['errorCode'];
    result.error = pigeonMap['error'];
    result.duration = pigeonMap['duration'];
    return result;
  }
}

class GetDuration {
  String path;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['path'] = path;
    return pigeonMap;
  }
  // ignore: unused_element
  static GetDuration _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final GetDuration result = GetDuration();
    result.path = pigeonMap['path'];
    return result;
  }
}

class SetVolume {
  SoundPlayerProxy player;
  int volume;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['player'] = player == null ? null : player._toMap();
    pigeonMap['volume'] = volume;
    return pigeonMap;
  }
  // ignore: unused_element
  static SetVolume _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final SetVolume result = SetVolume();
    result.player = SoundPlayerProxy._fromMap(pigeonMap['player']);
    result.volume = pigeonMap['volume'];
    return result;
  }
}

class SetPlaybackProgressInterval {
  SoundPlayerProxy player;
  int interval;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['player'] = player == null ? null : player._toMap();
    pigeonMap['interval'] = interval;
    return pigeonMap;
  }
  // ignore: unused_element
  static SetPlaybackProgressInterval _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final SetPlaybackProgressInterval result = SetPlaybackProgressInterval();
    result.player = SoundPlayerProxy._fromMap(pigeonMap['player']);
    result.interval = pigeonMap['interval'];
    return result;
  }
}

class RequestAudioFocus {
  SoundPlayerProxy player;
  AudioFocusProxy audioFocus;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['player'] = player == null ? null : player._toMap();
    pigeonMap['audioFocus'] = audioFocus == null ? null : audioFocus._toMap();
    return pigeonMap;
  }
  // ignore: unused_element
  static RequestAudioFocus _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final RequestAudioFocus result = RequestAudioFocus();
    result.player = SoundPlayerProxy._fromMap(pigeonMap['player']);
    result.audioFocus = AudioFocusProxy._fromMap(pigeonMap['audioFocus']);
    return result;
  }
}

class AudioFocusProxy {
  int audioFocusMode;
  int stopOthersNoResume;
  int stopOthersWithResume;
  int hushOthersWithResume;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['audioFocusMode'] = audioFocusMode;
    pigeonMap['stopOthersNoResume'] = stopOthersNoResume;
    pigeonMap['stopOthersWithResume'] = stopOthersWithResume;
    pigeonMap['hushOthersWithResume'] = hushOthersWithResume;
    return pigeonMap;
  }
  // ignore: unused_element
  static AudioFocusProxy _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final AudioFocusProxy result = AudioFocusProxy();
    result.audioFocusMode = pigeonMap['audioFocusMode'];
    result.stopOthersNoResume = pigeonMap['stopOthersNoResume'];
    result.stopOthersWithResume = pigeonMap['stopOthersWithResume'];
    result.hushOthersWithResume = pigeonMap['hushOthersWithResume'];
    return result;
  }
}

class BoolResponse {
  bool success;
  int errorCode;
  String error;
  bool boolResult;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['success'] = success;
    pigeonMap['errorCode'] = errorCode;
    pigeonMap['error'] = error;
    pigeonMap['boolResult'] = boolResult;
    return pigeonMap;
  }
  // ignore: unused_element
  static BoolResponse _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final BoolResponse result = BoolResponse();
    result.success = pigeonMap['success'];
    result.errorCode = pigeonMap['errorCode'];
    result.error = pigeonMap['error'];
    result.boolResult = pigeonMap['boolResult'];
    return result;
  }
}

class SoundRecorderProxy {
  String uuid;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['uuid'] = uuid;
    return pigeonMap;
  }
  // ignore: unused_element
  static SoundRecorderProxy _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final SoundRecorderProxy result = SoundRecorderProxy();
    result.uuid = pigeonMap['uuid'];
    return result;
  }
}

class StartRecording {
  SoundRecorderProxy recorder;
  TrackProxy track;
  AudioSourceProxy audioSource;
  QualityProxy quality;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['recorder'] = recorder == null ? null : recorder._toMap();
    pigeonMap['track'] = track == null ? null : track._toMap();
    pigeonMap['audioSource'] = audioSource == null ? null : audioSource._toMap();
    pigeonMap['quality'] = quality == null ? null : quality._toMap();
    return pigeonMap;
  }
  // ignore: unused_element
  static StartRecording _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final StartRecording result = StartRecording();
    result.recorder = SoundRecorderProxy._fromMap(pigeonMap['recorder']);
    result.track = TrackProxy._fromMap(pigeonMap['track']);
    result.audioSource = AudioSourceProxy._fromMap(pigeonMap['audioSource']);
    result.quality = QualityProxy._fromMap(pigeonMap['quality']);
    return result;
  }
}

class AudioSourceProxy {
  int audioSource;
  int defaultSource;
  int mic;
  int voiceUplink;
  int voiceDownlink;
  int camcorder;
  int voiceRecognition;
  int voiceCommunication;
  int remoteSubmix;
  int unprocessed;
  int radioTuner;
  int hotword;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['audioSource'] = audioSource;
    pigeonMap['defaultSource'] = defaultSource;
    pigeonMap['mic'] = mic;
    pigeonMap['voiceUplink'] = voiceUplink;
    pigeonMap['voiceDownlink'] = voiceDownlink;
    pigeonMap['camcorder'] = camcorder;
    pigeonMap['voiceRecognition'] = voiceRecognition;
    pigeonMap['voiceCommunication'] = voiceCommunication;
    pigeonMap['remoteSubmix'] = remoteSubmix;
    pigeonMap['unprocessed'] = unprocessed;
    pigeonMap['radioTuner'] = radioTuner;
    pigeonMap['hotword'] = hotword;
    return pigeonMap;
  }
  // ignore: unused_element
  static AudioSourceProxy _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final AudioSourceProxy result = AudioSourceProxy();
    result.audioSource = pigeonMap['audioSource'];
    result.defaultSource = pigeonMap['defaultSource'];
    result.mic = pigeonMap['mic'];
    result.voiceUplink = pigeonMap['voiceUplink'];
    result.voiceDownlink = pigeonMap['voiceDownlink'];
    result.camcorder = pigeonMap['camcorder'];
    result.voiceRecognition = pigeonMap['voiceRecognition'];
    result.voiceCommunication = pigeonMap['voiceCommunication'];
    result.remoteSubmix = pigeonMap['remoteSubmix'];
    result.unprocessed = pigeonMap['unprocessed'];
    result.radioTuner = pigeonMap['radioTuner'];
    result.hotword = pigeonMap['hotword'];
    return result;
  }
}

class QualityProxy {
  int quality;
  int min;
  int low;
  int medium;
  int high;
  int max;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['quality'] = quality;
    pigeonMap['min'] = min;
    pigeonMap['low'] = low;
    pigeonMap['medium'] = medium;
    pigeonMap['high'] = high;
    pigeonMap['max'] = max;
    return pigeonMap;
  }
  // ignore: unused_element
  static QualityProxy _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final QualityProxy result = QualityProxy();
    result.quality = pigeonMap['quality'];
    result.min = pigeonMap['min'];
    result.low = pigeonMap['low'];
    result.medium = pigeonMap['medium'];
    result.high = pigeonMap['high'];
    result.max = pigeonMap['max'];
    return result;
  }
}

class MediaFormatResponse {
  bool success;
  int errorCode;
  String error;
  List mediaFormats;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['success'] = success;
    pigeonMap['errorCode'] = errorCode;
    pigeonMap['error'] = error;
    pigeonMap['mediaFormats'] = mediaFormats;
    return pigeonMap;
  }
  // ignore: unused_element
  static MediaFormatResponse _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final MediaFormatResponse result = MediaFormatResponse();
    result.success = pigeonMap['success'];
    result.errorCode = pigeonMap['errorCode'];
    result.error = pigeonMap['error'];
    result.mediaFormats = pigeonMap['mediaFormats'];
    return result;
  }
}

class SetRecordingProgressInterval {
  SoundRecorderProxy recorder;
  int interval;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['recorder'] = recorder == null ? null : recorder._toMap();
    pigeonMap['interval'] = interval;
    return pigeonMap;
  }
  // ignore: unused_element
  static SetRecordingProgressInterval _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final SetRecordingProgressInterval result = SetRecordingProgressInterval();
    result.recorder = SoundRecorderProxy._fromMap(pigeonMap['recorder']);
    result.interval = pigeonMap['interval'];
    return result;
  }
}

class OnPlaybackProgress {
  SoundPlayerProxy player;
  TrackProxy track;
  int duration;
  int position;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['player'] = player == null ? null : player._toMap();
    pigeonMap['track'] = track == null ? null : track._toMap();
    pigeonMap['duration'] = duration;
    pigeonMap['position'] = position;
    return pigeonMap;
  }
  // ignore: unused_element
  static OnPlaybackProgress _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final OnPlaybackProgress result = OnPlaybackProgress();
    result.player = SoundPlayerProxy._fromMap(pigeonMap['player']);
    result.track = TrackProxy._fromMap(pigeonMap['track']);
    result.duration = pigeonMap['duration'];
    result.position = pigeonMap['position'];
    return result;
  }
}

class OnPlaybackFinished {
  SoundPlayerProxy player;
  TrackProxy track;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['player'] = player == null ? null : player._toMap();
    pigeonMap['track'] = track == null ? null : track._toMap();
    return pigeonMap;
  }
  // ignore: unused_element
  static OnPlaybackFinished _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final OnPlaybackFinished result = OnPlaybackFinished();
    result.player = SoundPlayerProxy._fromMap(pigeonMap['player']);
    result.track = TrackProxy._fromMap(pigeonMap['track']);
    return result;
  }
}

class OnShadeSkipForward {
  SoundPlayerProxy player;
  TrackProxy track;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['player'] = player == null ? null : player._toMap();
    pigeonMap['track'] = track == null ? null : track._toMap();
    return pigeonMap;
  }
  // ignore: unused_element
  static OnShadeSkipForward _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final OnShadeSkipForward result = OnShadeSkipForward();
    result.player = SoundPlayerProxy._fromMap(pigeonMap['player']);
    result.track = TrackProxy._fromMap(pigeonMap['track']);
    return result;
  }
}

class OnShadeSkipBackward {
  SoundPlayerProxy player;
  TrackProxy track;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['player'] = player == null ? null : player._toMap();
    pigeonMap['track'] = track == null ? null : track._toMap();
    return pigeonMap;
  }
  // ignore: unused_element
  static OnShadeSkipBackward _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final OnShadeSkipBackward result = OnShadeSkipBackward();
    result.player = SoundPlayerProxy._fromMap(pigeonMap['player']);
    result.track = TrackProxy._fromMap(pigeonMap['track']);
    return result;
  }
}

class OnShadePaused {
  SoundPlayerProxy player;
  TrackProxy track;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['player'] = player == null ? null : player._toMap();
    pigeonMap['track'] = track == null ? null : track._toMap();
    return pigeonMap;
  }
  // ignore: unused_element
  static OnShadePaused _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final OnShadePaused result = OnShadePaused();
    result.player = SoundPlayerProxy._fromMap(pigeonMap['player']);
    result.track = TrackProxy._fromMap(pigeonMap['track']);
    return result;
  }
}

class OnShadeResumed {
  SoundPlayerProxy player;
  TrackProxy track;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['player'] = player == null ? null : player._toMap();
    pigeonMap['track'] = track == null ? null : track._toMap();
    return pigeonMap;
  }
  // ignore: unused_element
  static OnShadeResumed _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final OnShadeResumed result = OnShadeResumed();
    result.player = SoundPlayerProxy._fromMap(pigeonMap['player']);
    result.track = TrackProxy._fromMap(pigeonMap['track']);
    return result;
  }
}

class OnRecordingProgress {
  SoundRecorderProxy recorder;
  TrackProxy track;
  double decibels;
  int duration;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['recorder'] = recorder == null ? null : recorder._toMap();
    pigeonMap['track'] = track == null ? null : track._toMap();
    pigeonMap['decibels'] = decibels;
    pigeonMap['duration'] = duration;
    return pigeonMap;
  }
  // ignore: unused_element
  static OnRecordingProgress _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final OnRecordingProgress result = OnRecordingProgress();
    result.recorder = SoundRecorderProxy._fromMap(pigeonMap['recorder']);
    result.track = TrackProxy._fromMap(pigeonMap['track']);
    result.decibels = pigeonMap['decibels'];
    result.duration = pigeonMap['duration'];
    return result;
  }
}

class OnError {
  int errorCode;
  String error;
  // ignore: unused_element
  Map<dynamic, dynamic> _toMap() {
    final Map<dynamic, dynamic> pigeonMap = <dynamic, dynamic>{};
    pigeonMap['errorCode'] = errorCode;
    pigeonMap['error'] = error;
    return pigeonMap;
  }
  // ignore: unused_element
  static OnError _fromMap(Map<dynamic, dynamic> pigeonMap) {
    if (pigeonMap == null){
      return null;
    }
    final OnError result = OnError();
    result.errorCode = pigeonMap['errorCode'];
    result.error = pigeonMap['error'];
    return result;
  }
}

class SoundsToPlatformApi {
  Future<Response> initializePlayer(InitializePlayer arg) async {
    final Map<dynamic, dynamic> requestMap = arg._toMap();
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.initializePlayer', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(requestMap);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return Response._fromMap(replyMap['result']);
    }
    
  }
  Future<Response> initializePlayerWithShade(InitializePlayerWithShade arg) async {
    final Map<dynamic, dynamic> requestMap = arg._toMap();
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.initializePlayerWithShade', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(requestMap);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return Response._fromMap(replyMap['result']);
    }
    
  }
  Future<Response> releasePlayer(SoundPlayerProxy arg) async {
    final Map<dynamic, dynamic> requestMap = arg._toMap();
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.releasePlayer', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(requestMap);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return Response._fromMap(replyMap['result']);
    }
    
  }
  Future<Response> startPlayer(StartPlayer arg) async {
    final Map<dynamic, dynamic> requestMap = arg._toMap();
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.startPlayer', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(requestMap);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return Response._fromMap(replyMap['result']);
    }
    
  }
  Future<Response> stopPlayer(SoundPlayerProxy arg) async {
    final Map<dynamic, dynamic> requestMap = arg._toMap();
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.stopPlayer', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(requestMap);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return Response._fromMap(replyMap['result']);
    }
    
  }
  Future<Response> pausePlayer(SoundPlayerProxy arg) async {
    final Map<dynamic, dynamic> requestMap = arg._toMap();
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.pausePlayer', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(requestMap);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return Response._fromMap(replyMap['result']);
    }
    
  }
  Future<Response> resumePlayer(SoundPlayerProxy arg) async {
    final Map<dynamic, dynamic> requestMap = arg._toMap();
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.resumePlayer', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(requestMap);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return Response._fromMap(replyMap['result']);
    }
    
  }
  Future<Response> seekToPlayer(SeekToPlayer arg) async {
    final Map<dynamic, dynamic> requestMap = arg._toMap();
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.seekToPlayer', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(requestMap);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return Response._fromMap(replyMap['result']);
    }
    
  }
  Future<DurationResponse> getDuration(GetDuration arg) async {
    final Map<dynamic, dynamic> requestMap = arg._toMap();
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.getDuration', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(requestMap);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return DurationResponse._fromMap(replyMap['result']);
    }
    
  }
  Future<Response> setVolume(SetVolume arg) async {
    final Map<dynamic, dynamic> requestMap = arg._toMap();
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.setVolume', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(requestMap);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return Response._fromMap(replyMap['result']);
    }
    
  }
  Future<Response> setPlaybackProgressInterval(SetPlaybackProgressInterval arg) async {
    final Map<dynamic, dynamic> requestMap = arg._toMap();
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.setPlaybackProgressInterval', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(requestMap);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return Response._fromMap(replyMap['result']);
    }
    
  }
  Future<Response> requestAudioFocus(RequestAudioFocus arg) async {
    final Map<dynamic, dynamic> requestMap = arg._toMap();
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.requestAudioFocus', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(requestMap);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return Response._fromMap(replyMap['result']);
    }
    
  }
  Future<Response> releaseAudioFocus(SoundPlayerProxy arg) async {
    final Map<dynamic, dynamic> requestMap = arg._toMap();
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.releaseAudioFocus', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(requestMap);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return Response._fromMap(replyMap['result']);
    }
    
  }
  Future<BoolResponse> isShadeSupported() async {
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.isShadeSupported', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(null);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return BoolResponse._fromMap(replyMap['result']);
    }
    
  }
  Future<BoolResponse> isShadePauseSupported() async {
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.isShadePauseSupported', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(null);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return BoolResponse._fromMap(replyMap['result']);
    }
    
  }
  Future<BoolResponse> isShadeSkipForwardSupported() async {
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.isShadeSkipForwardSupported', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(null);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return BoolResponse._fromMap(replyMap['result']);
    }
    
  }
  Future<BoolResponse> isShadeSkipBackwardsSupported() async {
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.isShadeSkipBackwardsSupported', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(null);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return BoolResponse._fromMap(replyMap['result']);
    }
    
  }
  Future<BoolResponse> isBackgroundPlaybackSupported() async {
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.isBackgroundPlaybackSupported', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(null);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return BoolResponse._fromMap(replyMap['result']);
    }
    
  }
  Future<Response> initializeRecorder(SoundRecorderProxy arg) async {
    final Map<dynamic, dynamic> requestMap = arg._toMap();
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.initializeRecorder', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(requestMap);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return Response._fromMap(replyMap['result']);
    }
    
  }
  Future<Response> releaseRecorder(SoundRecorderProxy arg) async {
    final Map<dynamic, dynamic> requestMap = arg._toMap();
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.releaseRecorder', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(requestMap);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return Response._fromMap(replyMap['result']);
    }
    
  }
  Future<Response> startRecording(StartRecording arg) async {
    final Map<dynamic, dynamic> requestMap = arg._toMap();
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.startRecording', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(requestMap);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return Response._fromMap(replyMap['result']);
    }
    
  }
  Future<Response> stopRecording(SoundRecorderProxy arg) async {
    final Map<dynamic, dynamic> requestMap = arg._toMap();
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.stopRecording', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(requestMap);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return Response._fromMap(replyMap['result']);
    }
    
  }
  Future<Response> pauseRecording(SoundRecorderProxy arg) async {
    final Map<dynamic, dynamic> requestMap = arg._toMap();
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.pauseRecording', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(requestMap);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return Response._fromMap(replyMap['result']);
    }
    
  }
  Future<Response> resumeRecording(SoundRecorderProxy arg) async {
    final Map<dynamic, dynamic> requestMap = arg._toMap();
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.resumeRecording', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(requestMap);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return Response._fromMap(replyMap['result']);
    }
    
  }
  Future<MediaFormatResponse> getNativeEncoderFormats(MediaFormatProxy arg) async {
    final Map<dynamic, dynamic> requestMap = arg._toMap();
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.getNativeEncoderFormats', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(requestMap);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return MediaFormatResponse._fromMap(replyMap['result']);
    }
    
  }
  Future<MediaFormatResponse> getNativeDecoderFormats(MediaFormatProxy arg) async {
    final Map<dynamic, dynamic> requestMap = arg._toMap();
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.getNativeDecoderFormats', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(requestMap);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return MediaFormatResponse._fromMap(replyMap['result']);
    }
    
  }
  Future<Response> setRecordingProgressInterval(SetRecordingProgressInterval arg) async {
    final Map<dynamic, dynamic> requestMap = arg._toMap();
    const BasicMessageChannel<dynamic> channel =
        BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsToPlatformApi.setRecordingProgressInterval', StandardMessageCodec());
    
    final Map<dynamic, dynamic> replyMap = await channel.send(requestMap);
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null);
    } else if (replyMap['error'] != null) {
      final Map<dynamic, dynamic> error = replyMap['error'];
      throw PlatformException(
          code: error['code'],
          message: error['message'],
          details: error['details']);
    } else {
      return Response._fromMap(replyMap['result']);
    }
    
  }
}

abstract class SoundsFromPlatformApi {
  void onPlaybackProgress(OnPlaybackProgress arg);
  void onPlaybackFinished(OnPlaybackFinished arg);
  void onShadeSkipForward(OnShadeSkipForward arg);
  void onShadeSkipBackward(OnShadeSkipBackward arg);
  void onShadePaused(OnShadePaused arg);
  void onShadeResumed(OnShadeResumed arg);
  void onRecordingProgress(OnRecordingProgress arg);
  void onError(OnError arg);
  static void setup(SoundsFromPlatformApi api) {
    {
      const BasicMessageChannel<dynamic> channel =
          BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsFromPlatformApi.onPlaybackProgress', StandardMessageCodec());
      channel.setMessageHandler((dynamic message) async {
        final Map<dynamic, dynamic> mapMessage = message as Map<dynamic, dynamic>;
        final OnPlaybackProgress input = OnPlaybackProgress._fromMap(mapMessage);
        api.onPlaybackProgress(input);
      });
    }
    {
      const BasicMessageChannel<dynamic> channel =
          BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsFromPlatformApi.onPlaybackFinished', StandardMessageCodec());
      channel.setMessageHandler((dynamic message) async {
        final Map<dynamic, dynamic> mapMessage = message as Map<dynamic, dynamic>;
        final OnPlaybackFinished input = OnPlaybackFinished._fromMap(mapMessage);
        api.onPlaybackFinished(input);
      });
    }
    {
      const BasicMessageChannel<dynamic> channel =
          BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsFromPlatformApi.onShadeSkipForward', StandardMessageCodec());
      channel.setMessageHandler((dynamic message) async {
        final Map<dynamic, dynamic> mapMessage = message as Map<dynamic, dynamic>;
        final OnShadeSkipForward input = OnShadeSkipForward._fromMap(mapMessage);
        api.onShadeSkipForward(input);
      });
    }
    {
      const BasicMessageChannel<dynamic> channel =
          BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsFromPlatformApi.onShadeSkipBackward', StandardMessageCodec());
      channel.setMessageHandler((dynamic message) async {
        final Map<dynamic, dynamic> mapMessage = message as Map<dynamic, dynamic>;
        final OnShadeSkipBackward input = OnShadeSkipBackward._fromMap(mapMessage);
        api.onShadeSkipBackward(input);
      });
    }
    {
      const BasicMessageChannel<dynamic> channel =
          BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsFromPlatformApi.onShadePaused', StandardMessageCodec());
      channel.setMessageHandler((dynamic message) async {
        final Map<dynamic, dynamic> mapMessage = message as Map<dynamic, dynamic>;
        final OnShadePaused input = OnShadePaused._fromMap(mapMessage);
        api.onShadePaused(input);
      });
    }
    {
      const BasicMessageChannel<dynamic> channel =
          BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsFromPlatformApi.onShadeResumed', StandardMessageCodec());
      channel.setMessageHandler((dynamic message) async {
        final Map<dynamic, dynamic> mapMessage = message as Map<dynamic, dynamic>;
        final OnShadeResumed input = OnShadeResumed._fromMap(mapMessage);
        api.onShadeResumed(input);
      });
    }
    {
      const BasicMessageChannel<dynamic> channel =
          BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsFromPlatformApi.onRecordingProgress', StandardMessageCodec());
      channel.setMessageHandler((dynamic message) async {
        final Map<dynamic, dynamic> mapMessage = message as Map<dynamic, dynamic>;
        final OnRecordingProgress input = OnRecordingProgress._fromMap(mapMessage);
        api.onRecordingProgress(input);
      });
    }
    {
      const BasicMessageChannel<dynamic> channel =
          BasicMessageChannel<dynamic>('dev.flutter.pigeon.SoundsFromPlatformApi.onError', StandardMessageCodec());
      channel.setMessageHandler((dynamic message) async {
        final Map<dynamic, dynamic> mapMessage = message as Map<dynamic, dynamic>;
        final OnError input = OnError._fromMap(mapMessage);
        api.onError(input);
      });
    }
  }
}


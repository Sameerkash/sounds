// // Generated by @dartnative/codegen:
// // https://www.npmjs.com/package/@dartnative/codegen

// import 'dart:ffi';

// import 'package:dart_native/dart_native.dart';
// import 'package:dart_native_gen/dart_native_gen.dart';

// import 'avaudioformat.dart';
// import 'hacks.dart';
// // You can uncomment this line when this package is ready.
// // import 'package:avfaudio/avaudioformat.dart';

// @NativeAvailable(macos: '10.10', ios: '8.0', watchos: '2.0', tvos: '9.0')
// @native

// ///
// class AVAudioFile extends NSObject {
//   ///
//   AVAudioFile([Class isa]) : super(isa ?? Class('AVAudioFile'));

//   ///
//   AVAudioFile.fromPointer(Pointer<Void> ptr) : super.fromPointer(ptr);

//   ///
//   NSURL get url {
//     Pointer<Void> result =
//         perform(SEL('url'), decodeRetVal: false) as Pointer<Void>;

//     return NSURL.fromPointer(result) as NSURL;
//   }

//   set url(NSURL url) => perform(SEL('setUrl:'), args: <NSURL>[url]);

//   AVAudioFormat get fileFormat {
//     Pointer<Void> result =
//         perform(SEL('fileFormat'), decodeRetVal: false) as Pointer<Void>;
//     return AVAudioFormat.fromPointer(result);
//   }

//   set fileFormat(AVAudioFormat fileFormat) =>
//       perform(SEL('setFileFormat:'), args: <dynamic>[fileFormat]);

//   AVAudioFormat get processingFormat {
//     Pointer<Void> result =
//         perform(SEL('processingFormat'), decodeRetVal: false) as Pointer<Void>;
//     return AVAudioFormat.fromPointer(result);
//   }

//   ///
//   set processingFormat(AVAudioFormat processingFormat) =>
//       perform(SEL('setProcessingFormat:'),
//           args: <AVAudioFormat>[processingFormat]);

//   AVAudioFramePosition get length {
//     Pointer<Void> result =
//         perform(SEL('length'), decodeRetVal: false) as Pointer<Void>;
//     return AVAudioFramePosition.fromPointer(result);
//   }

//   ///
//   set length(AVAudioFramePosition length) =>
//       perform(SEL('setLength:'), args: <dynamic>[length]);

//   AVAudioFramePosition get framePosition {
//     Pointer<Void> result =
//         perform(SEL('framePosition'), decodeRetVal: false) as Pointer<Void>;
//     return AVAudioFramePosition.fromPointer(result);
//   }

//   ///
//   set framePosition(AVAudioFramePosition framePosition) =>
//       perform(SEL('setFramePosition:'),
//           args: <AVAudioFramePosition>[framePosition]);
//   AVAudioFile.initForReadingError(NSURL fileURL, NSObjectRef<NSError> outError)
//       : super.fromPointer(_initForReadingError(fileURL, outError));

//   ///
//   static Pointer<Void> _initForReadingError(
//       NSURL fileURL, NSObjectRef<NSError> outError) {
//     Pointer<Void> target = alloc(Class('AVAudioFile'));
//     SEL sel = SEL('initForReading:error:');
//     return msgSend(target, sel,
//         args: <dynamic>[fileURL, outError],
//         decodeRetVal: false) as Pointer<Void>;
//   }

//   ///
//   AVAudioFile.initForReadingCommonFormatInterleavedError(
//       NSURL fileURL,
//       AVAudioCommonFormat format,
//       bool interleaved,
//       NSObjectRef<NSError> outError)
//       : super.fromPointer(_initForReadingCommonFormatInterleavedError(
//             fileURL, format, interleaved, outError));

//   static Pointer<Void> _initForReadingCommonFormatInterleavedError(
//       NSURL fileURL,
//       AVAudioCommonFormat format,
//       bool interleaved,
//       NSObjectRef<NSError> outError) {
//     Pointer<Void> target = alloc(Class('AVAudioFile'));
//     SEL sel = SEL('initForReading:commonFormat:interleaved:error:');
//     return msgSend(target, sel,
//         args: <dynamic>[fileURL, format, interleaved, outError],
//         decodeRetVal: false) as Pointer<Void>;
//   }

//   ///
//   AVAudioFile.initForWritingSettingsError(
//       NSURL fileURL, NSObject settings, NSObjectRef<NSError> outError)
//       : super.fromPointer(
//             _initForWritingSettingsError(fileURL, settings, outError));

//   ///
//   static Pointer<Void> _initForWritingSettingsError(
//       NSURL fileURL, NSObject settings, NSObjectRef<NSError> outError) {
//     Pointer<Void> target = alloc(Class('AVAudioFile'));
//     SEL sel = SEL('initForWriting:settings:error:');
//     return msgSend(target, sel,
//         args: <dynamic>[fileURL, settings, outError],
//         decodeRetVal: false) as Pointer<Void>;
//   }

//   ///
//   AVAudioFile.initForWritingSettingsCommonFormatInterleavedError(
//       NSURL fileURL,
//       NSObject settings,
//       AVAudioCommonFormat format,
//       bool interleaved,
//       NSObjectRef<NSError> outError)
//       : super.fromPointer(_initForWritingSettingsCommonFormatInterleavedError(
//             fileURL, settings, format, interleaved, outError));

//   ///
//   static Pointer<Void> _initForWritingSettingsCommonFormatInterleavedError(
//       NSURL fileURL,
//       NSObject settings,
//       AVAudioCommonFormat format,
//       bool interleaved,
//       NSObjectRef<NSError> outError) {
//     Pointer<Void> target = alloc(Class('AVAudioFile'));
//     SEL sel = SEL('initForWriting:settings:commonFormat:interleaved:error:');
//     return msgSend(target, sel,
//         args: <dynamic>[fileURL, settings, format, interleaved, outError],
//         decodeRetVal: false) as Pointer<Void>;
//   }

//   ///
//   bool readIntoBufferError(
//       AVAudioPCMBuffer buffer, NSObjectRef<NSError> outError) {
//     return perform(SEL('readIntoBuffer:error:'),
//         args: <dynamic>[buffer, outError]) as bool;
//   }

//   ///
//   bool readIntoBufferFrameCountError(AVAudioPCMBuffer buffer,
//       AVAudioFrameCount frames, NSObjectRef<NSError> outError) {
//     return perform(SEL('readIntoBuffer:frameCount:error:'),
//         args: <dynamic>[buffer, frames, outError]) as bool;
//   }

//   ///
//   bool writeFromBufferError(
//       AVAudioPCMBuffer buffer, NSObjectRef<NSError> outError) {
//     return perform(SEL('writeFromBuffer:error:'),
//         args: <dynamic>[buffer, outError]) as bool;
//   }
// }
